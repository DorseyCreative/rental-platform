"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/signature_pad";
exports.ids = ["vendor-chunks/signature_pad"];
exports.modules = {

/***/ "(ssr)/./node_modules/signature_pad/dist/signature_pad.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/signature_pad/dist/signature_pad.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*!\n * Signature Pad v2.3.2\n * https://github.com/szimek/signature_pad\n *\n * Copyright 2017 Szymon Nowak\n * Released under the MIT license\n *\n * The main idea and some parts of the code (e.g. drawing variable width Bézier curve) are taken from:\n * http://corner.squareup.com/2012/07/smoother-signatures.html\n *\n * Implementation of interpolation using cubic Bézier curves is taken from:\n * http://benknowscode.wordpress.com/2012/09/14/path-interpolation-using-cubic-bezier-and-control-point-estimation-in-javascript\n *\n * Algorithm for approximated length of a Bézier curve is taken from:\n * http://www.lemoda.net/maths/bezier-length/index.html\n *\n */ function Point(x, y, time) {\n    this.x = x;\n    this.y = y;\n    this.time = time || new Date().getTime();\n}\nPoint.prototype.velocityFrom = function(start) {\n    return this.time !== start.time ? this.distanceTo(start) / (this.time - start.time) : 1;\n};\nPoint.prototype.distanceTo = function(start) {\n    return Math.sqrt(Math.pow(this.x - start.x, 2) + Math.pow(this.y - start.y, 2));\n};\nPoint.prototype.equals = function(other) {\n    return this.x === other.x && this.y === other.y && this.time === other.time;\n};\nfunction Bezier(startPoint, control1, control2, endPoint) {\n    this.startPoint = startPoint;\n    this.control1 = control1;\n    this.control2 = control2;\n    this.endPoint = endPoint;\n}\n// Returns approximated length.\nBezier.prototype.length = function() {\n    var steps = 10;\n    var length = 0;\n    var px = void 0;\n    var py = void 0;\n    for(var i = 0; i <= steps; i += 1){\n        var t = i / steps;\n        var cx = this._point(t, this.startPoint.x, this.control1.x, this.control2.x, this.endPoint.x);\n        var cy = this._point(t, this.startPoint.y, this.control1.y, this.control2.y, this.endPoint.y);\n        if (i > 0) {\n            var xdiff = cx - px;\n            var ydiff = cy - py;\n            length += Math.sqrt(xdiff * xdiff + ydiff * ydiff);\n        }\n        px = cx;\n        py = cy;\n    }\n    return length;\n};\n/* eslint-disable no-multi-spaces, space-in-parens */ Bezier.prototype._point = function(t, start, c1, c2, end) {\n    return start * (1.0 - t) * (1.0 - t) * (1.0 - t) + 3.0 * c1 * (1.0 - t) * (1.0 - t) * t + 3.0 * c2 * (1.0 - t) * t * t + end * t * t * t;\n};\n/* eslint-disable */ // http://stackoverflow.com/a/27078401/815507\nfunction throttle(func, wait, options) {\n    var context, args, result;\n    var timeout = null;\n    var previous = 0;\n    if (!options) options = {};\n    var later = function later() {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n    };\n    return function() {\n        var now = Date.now();\n        if (!previous && options.leading === false) previous = now;\n        var remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n            if (timeout) {\n                clearTimeout(timeout);\n                timeout = null;\n            }\n            previous = now;\n            result = func.apply(context, args);\n            if (!timeout) context = args = null;\n        } else if (!timeout && options.trailing !== false) {\n            timeout = setTimeout(later, remaining);\n        }\n        return result;\n    };\n}\nfunction SignaturePad(canvas, options) {\n    var self = this;\n    var opts = options || {};\n    this.velocityFilterWeight = opts.velocityFilterWeight || 0.7;\n    this.minWidth = opts.minWidth || 0.5;\n    this.maxWidth = opts.maxWidth || 2.5;\n    this.throttle = \"throttle\" in opts ? opts.throttle : 16; // in miliseconds\n    this.minDistance = \"minDistance\" in opts ? opts.minDistance : 5;\n    if (this.throttle) {\n        this._strokeMoveUpdate = throttle(SignaturePad.prototype._strokeUpdate, this.throttle);\n    } else {\n        this._strokeMoveUpdate = SignaturePad.prototype._strokeUpdate;\n    }\n    this.dotSize = opts.dotSize || function() {\n        return (this.minWidth + this.maxWidth) / 2;\n    };\n    this.penColor = opts.penColor || \"black\";\n    this.backgroundColor = opts.backgroundColor || \"rgba(0,0,0,0)\";\n    this.onBegin = opts.onBegin;\n    this.onEnd = opts.onEnd;\n    this._canvas = canvas;\n    this._ctx = canvas.getContext(\"2d\");\n    this.clear();\n    // We need add these inline so they are available to unbind while still having\n    // access to 'self' we could use _.bind but it's not worth adding a dependency.\n    this._handleMouseDown = function(event) {\n        if (event.which === 1) {\n            self._mouseButtonDown = true;\n            self._strokeBegin(event);\n        }\n    };\n    this._handleMouseMove = function(event) {\n        if (self._mouseButtonDown) {\n            self._strokeMoveUpdate(event);\n        }\n    };\n    this._handleMouseUp = function(event) {\n        if (event.which === 1 && self._mouseButtonDown) {\n            self._mouseButtonDown = false;\n            self._strokeEnd(event);\n        }\n    };\n    this._handleTouchStart = function(event) {\n        if (event.targetTouches.length === 1) {\n            var touch = event.changedTouches[0];\n            self._strokeBegin(touch);\n        }\n    };\n    this._handleTouchMove = function(event) {\n        // Prevent scrolling.\n        event.preventDefault();\n        var touch = event.targetTouches[0];\n        self._strokeMoveUpdate(touch);\n    };\n    this._handleTouchEnd = function(event) {\n        var wasCanvasTouched = event.target === self._canvas;\n        if (wasCanvasTouched) {\n            event.preventDefault();\n            self._strokeEnd(event);\n        }\n    };\n    // Enable mouse and touch event handlers\n    this.on();\n}\n// Public methods\nSignaturePad.prototype.clear = function() {\n    var ctx = this._ctx;\n    var canvas = this._canvas;\n    ctx.fillStyle = this.backgroundColor;\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    this._data = [];\n    this._reset();\n    this._isEmpty = true;\n};\nSignaturePad.prototype.fromDataURL = function(dataUrl) {\n    var _this = this;\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var image = new Image();\n    var ratio = options.ratio || window.devicePixelRatio || 1;\n    var width = options.width || this._canvas.width / ratio;\n    var height = options.height || this._canvas.height / ratio;\n    this._reset();\n    image.src = dataUrl;\n    image.onload = function() {\n        _this._ctx.drawImage(image, 0, 0, width, height);\n    };\n    this._isEmpty = false;\n};\nSignaturePad.prototype.toDataURL = function(type) {\n    var _canvas;\n    switch(type){\n        case \"image/svg+xml\":\n            return this._toSVG();\n        default:\n            for(var _len = arguments.length, options = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                options[_key - 1] = arguments[_key];\n            }\n            return (_canvas = this._canvas).toDataURL.apply(_canvas, [\n                type\n            ].concat(options));\n    }\n};\nSignaturePad.prototype.on = function() {\n    this._handleMouseEvents();\n    this._handleTouchEvents();\n};\nSignaturePad.prototype.off = function() {\n    this._canvas.removeEventListener(\"mousedown\", this._handleMouseDown);\n    this._canvas.removeEventListener(\"mousemove\", this._handleMouseMove);\n    document.removeEventListener(\"mouseup\", this._handleMouseUp);\n    this._canvas.removeEventListener(\"touchstart\", this._handleTouchStart);\n    this._canvas.removeEventListener(\"touchmove\", this._handleTouchMove);\n    this._canvas.removeEventListener(\"touchend\", this._handleTouchEnd);\n};\nSignaturePad.prototype.isEmpty = function() {\n    return this._isEmpty;\n};\n// Private methods\nSignaturePad.prototype._strokeBegin = function(event) {\n    this._data.push([]);\n    this._reset();\n    this._strokeUpdate(event);\n    if (typeof this.onBegin === \"function\") {\n        this.onBegin(event);\n    }\n};\nSignaturePad.prototype._strokeUpdate = function(event) {\n    var x = event.clientX;\n    var y = event.clientY;\n    var point = this._createPoint(x, y);\n    var lastPointGroup = this._data[this._data.length - 1];\n    var lastPoint = lastPointGroup && lastPointGroup[lastPointGroup.length - 1];\n    var isLastPointTooClose = lastPoint && point.distanceTo(lastPoint) < this.minDistance;\n    // Skip this point if it's too close to the previous one\n    if (!(lastPoint && isLastPointTooClose)) {\n        var _addPoint = this._addPoint(point), curve = _addPoint.curve, widths = _addPoint.widths;\n        if (curve && widths) {\n            this._drawCurve(curve, widths.start, widths.end);\n        }\n        this._data[this._data.length - 1].push({\n            x: point.x,\n            y: point.y,\n            time: point.time,\n            color: this.penColor\n        });\n    }\n};\nSignaturePad.prototype._strokeEnd = function(event) {\n    var canDrawCurve = this.points.length > 2;\n    var point = this.points[0]; // Point instance\n    if (!canDrawCurve && point) {\n        this._drawDot(point);\n    }\n    if (point) {\n        var lastPointGroup = this._data[this._data.length - 1];\n        var lastPoint = lastPointGroup[lastPointGroup.length - 1]; // plain object\n        // When drawing a dot, there's only one point in a group, so without this check\n        // such group would end up with exactly the same 2 points.\n        if (!point.equals(lastPoint)) {\n            lastPointGroup.push({\n                x: point.x,\n                y: point.y,\n                time: point.time,\n                color: this.penColor\n            });\n        }\n    }\n    if (typeof this.onEnd === \"function\") {\n        this.onEnd(event);\n    }\n};\nSignaturePad.prototype._handleMouseEvents = function() {\n    this._mouseButtonDown = false;\n    this._canvas.addEventListener(\"mousedown\", this._handleMouseDown);\n    this._canvas.addEventListener(\"mousemove\", this._handleMouseMove);\n    document.addEventListener(\"mouseup\", this._handleMouseUp);\n};\nSignaturePad.prototype._handleTouchEvents = function() {\n    // Pass touch events to canvas element on mobile IE11 and Edge.\n    this._canvas.style.msTouchAction = \"none\";\n    this._canvas.style.touchAction = \"none\";\n    this._canvas.addEventListener(\"touchstart\", this._handleTouchStart);\n    this._canvas.addEventListener(\"touchmove\", this._handleTouchMove);\n    this._canvas.addEventListener(\"touchend\", this._handleTouchEnd);\n};\nSignaturePad.prototype._reset = function() {\n    this.points = [];\n    this._lastVelocity = 0;\n    this._lastWidth = (this.minWidth + this.maxWidth) / 2;\n    this._ctx.fillStyle = this.penColor;\n};\nSignaturePad.prototype._createPoint = function(x, y, time) {\n    var rect = this._canvas.getBoundingClientRect();\n    return new Point(x - rect.left, y - rect.top, time || new Date().getTime());\n};\nSignaturePad.prototype._addPoint = function(point) {\n    var points = this.points;\n    var tmp = void 0;\n    points.push(point);\n    if (points.length > 2) {\n        // To reduce the initial lag make it work with 3 points\n        // by copying the first point to the beginning.\n        if (points.length === 3) points.unshift(points[0]);\n        tmp = this._calculateCurveControlPoints(points[0], points[1], points[2]);\n        var c2 = tmp.c2;\n        tmp = this._calculateCurveControlPoints(points[1], points[2], points[3]);\n        var c3 = tmp.c1;\n        var curve = new Bezier(points[1], c2, c3, points[2]);\n        var widths = this._calculateCurveWidths(curve);\n        // Remove the first element from the list,\n        // so that we always have no more than 4 points in points array.\n        points.shift();\n        return {\n            curve: curve,\n            widths: widths\n        };\n    }\n    return {};\n};\nSignaturePad.prototype._calculateCurveControlPoints = function(s1, s2, s3) {\n    var dx1 = s1.x - s2.x;\n    var dy1 = s1.y - s2.y;\n    var dx2 = s2.x - s3.x;\n    var dy2 = s2.y - s3.y;\n    var m1 = {\n        x: (s1.x + s2.x) / 2.0,\n        y: (s1.y + s2.y) / 2.0\n    };\n    var m2 = {\n        x: (s2.x + s3.x) / 2.0,\n        y: (s2.y + s3.y) / 2.0\n    };\n    var l1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n    var l2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\n    var dxm = m1.x - m2.x;\n    var dym = m1.y - m2.y;\n    var k = l2 / (l1 + l2);\n    var cm = {\n        x: m2.x + dxm * k,\n        y: m2.y + dym * k\n    };\n    var tx = s2.x - cm.x;\n    var ty = s2.y - cm.y;\n    return {\n        c1: new Point(m1.x + tx, m1.y + ty),\n        c2: new Point(m2.x + tx, m2.y + ty)\n    };\n};\nSignaturePad.prototype._calculateCurveWidths = function(curve) {\n    var startPoint = curve.startPoint;\n    var endPoint = curve.endPoint;\n    var widths = {\n        start: null,\n        end: null\n    };\n    var velocity = this.velocityFilterWeight * endPoint.velocityFrom(startPoint) + (1 - this.velocityFilterWeight) * this._lastVelocity;\n    var newWidth = this._strokeWidth(velocity);\n    widths.start = this._lastWidth;\n    widths.end = newWidth;\n    this._lastVelocity = velocity;\n    this._lastWidth = newWidth;\n    return widths;\n};\nSignaturePad.prototype._strokeWidth = function(velocity) {\n    return Math.max(this.maxWidth / (velocity + 1), this.minWidth);\n};\nSignaturePad.prototype._drawPoint = function(x, y, size) {\n    var ctx = this._ctx;\n    ctx.moveTo(x, y);\n    ctx.arc(x, y, size, 0, 2 * Math.PI, false);\n    this._isEmpty = false;\n};\nSignaturePad.prototype._drawCurve = function(curve, startWidth, endWidth) {\n    var ctx = this._ctx;\n    var widthDelta = endWidth - startWidth;\n    var drawSteps = Math.floor(curve.length());\n    ctx.beginPath();\n    for(var i = 0; i < drawSteps; i += 1){\n        // Calculate the Bezier (x, y) coordinate for this step.\n        var t = i / drawSteps;\n        var tt = t * t;\n        var ttt = tt * t;\n        var u = 1 - t;\n        var uu = u * u;\n        var uuu = uu * u;\n        var x = uuu * curve.startPoint.x;\n        x += 3 * uu * t * curve.control1.x;\n        x += 3 * u * tt * curve.control2.x;\n        x += ttt * curve.endPoint.x;\n        var y = uuu * curve.startPoint.y;\n        y += 3 * uu * t * curve.control1.y;\n        y += 3 * u * tt * curve.control2.y;\n        y += ttt * curve.endPoint.y;\n        var width = startWidth + ttt * widthDelta;\n        this._drawPoint(x, y, width);\n    }\n    ctx.closePath();\n    ctx.fill();\n};\nSignaturePad.prototype._drawDot = function(point) {\n    var ctx = this._ctx;\n    var width = typeof this.dotSize === \"function\" ? this.dotSize() : this.dotSize;\n    ctx.beginPath();\n    this._drawPoint(point.x, point.y, width);\n    ctx.closePath();\n    ctx.fill();\n};\nSignaturePad.prototype._fromData = function(pointGroups, drawCurve, drawDot) {\n    for(var i = 0; i < pointGroups.length; i += 1){\n        var group = pointGroups[i];\n        if (group.length > 1) {\n            for(var j = 0; j < group.length; j += 1){\n                var rawPoint = group[j];\n                var point = new Point(rawPoint.x, rawPoint.y, rawPoint.time);\n                var color = rawPoint.color;\n                if (j === 0) {\n                    // First point in a group. Nothing to draw yet.\n                    // All points in the group have the same color, so it's enough to set\n                    // penColor just at the beginning.\n                    this.penColor = color;\n                    this._reset();\n                    this._addPoint(point);\n                } else if (j !== group.length - 1) {\n                    // Middle point in a group.\n                    var _addPoint2 = this._addPoint(point), curve = _addPoint2.curve, widths = _addPoint2.widths;\n                    if (curve && widths) {\n                        drawCurve(curve, widths, color);\n                    }\n                } else {\n                // Last point in a group. Do nothing.\n                }\n            }\n        } else {\n            this._reset();\n            var _rawPoint = group[0];\n            drawDot(_rawPoint);\n        }\n    }\n};\nSignaturePad.prototype._toSVG = function() {\n    var _this2 = this;\n    var pointGroups = this._data;\n    var canvas = this._canvas;\n    var ratio = Math.max(window.devicePixelRatio || 1, 1);\n    var minX = 0;\n    var minY = 0;\n    var maxX = canvas.width / ratio;\n    var maxY = canvas.height / ratio;\n    var svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n    svg.setAttributeNS(null, \"width\", canvas.width);\n    svg.setAttributeNS(null, \"height\", canvas.height);\n    this._fromData(pointGroups, function(curve, widths, color) {\n        var path = document.createElement(\"path\");\n        // Need to check curve for NaN values, these pop up when drawing\n        // lines on the canvas that are not continuous. E.g. Sharp corners\n        // or stopping mid-stroke and than continuing without lifting mouse.\n        if (!isNaN(curve.control1.x) && !isNaN(curve.control1.y) && !isNaN(curve.control2.x) && !isNaN(curve.control2.y)) {\n            var attr = \"M \" + curve.startPoint.x.toFixed(3) + \",\" + curve.startPoint.y.toFixed(3) + \" \" + (\"C \" + curve.control1.x.toFixed(3) + \",\" + curve.control1.y.toFixed(3) + \" \") + (curve.control2.x.toFixed(3) + \",\" + curve.control2.y.toFixed(3) + \" \") + (curve.endPoint.x.toFixed(3) + \",\" + curve.endPoint.y.toFixed(3));\n            path.setAttribute(\"d\", attr);\n            path.setAttribute(\"stroke-width\", (widths.end * 2.25).toFixed(3));\n            path.setAttribute(\"stroke\", color);\n            path.setAttribute(\"fill\", \"none\");\n            path.setAttribute(\"stroke-linecap\", \"round\");\n            svg.appendChild(path);\n        }\n    }, function(rawPoint) {\n        var circle = document.createElement(\"circle\");\n        var dotSize = typeof _this2.dotSize === \"function\" ? _this2.dotSize() : _this2.dotSize;\n        circle.setAttribute(\"r\", dotSize);\n        circle.setAttribute(\"cx\", rawPoint.x);\n        circle.setAttribute(\"cy\", rawPoint.y);\n        circle.setAttribute(\"fill\", rawPoint.color);\n        svg.appendChild(circle);\n    });\n    var prefix = \"data:image/svg+xml;base64,\";\n    var header = \"<svg\" + ' xmlns=\"http://www.w3.org/2000/svg\"' + ' xmlns:xlink=\"http://www.w3.org/1999/xlink\"' + (' viewBox=\"' + minX + \" \" + minY + \" \" + maxX + \" \" + maxY + '\"') + (' width=\"' + maxX + '\"') + (' height=\"' + maxY + '\"') + \">\";\n    var body = svg.innerHTML;\n    // IE hack for missing innerHTML property on SVGElement\n    if (body === undefined) {\n        var dummy = document.createElement(\"dummy\");\n        var nodes = svg.childNodes;\n        dummy.innerHTML = \"\";\n        for(var i = 0; i < nodes.length; i += 1){\n            dummy.appendChild(nodes[i].cloneNode(true));\n        }\n        body = dummy.innerHTML;\n    }\n    var footer = \"</svg>\";\n    var data = header + body + footer;\n    return prefix + btoa(data);\n};\nSignaturePad.prototype.fromData = function(pointGroups) {\n    var _this3 = this;\n    this.clear();\n    this._fromData(pointGroups, function(curve, widths) {\n        return _this3._drawCurve(curve, widths.start, widths.end);\n    }, function(rawPoint) {\n        return _this3._drawDot(rawPoint);\n    });\n    this._data = pointGroups;\n};\nSignaturePad.prototype.toData = function() {\n    return this._data;\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SignaturePad);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2lnbmF0dXJlX3BhZC9kaXN0L3NpZ25hdHVyZV9wYWQubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7OztDQWdCQyxHQUVELFNBQVNBLE1BQU1DLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxJQUFJO0lBQ3ZCLElBQUksQ0FBQ0YsQ0FBQyxHQUFHQTtJQUNULElBQUksQ0FBQ0MsQ0FBQyxHQUFHQTtJQUNULElBQUksQ0FBQ0MsSUFBSSxHQUFHQSxRQUFRLElBQUlDLE9BQU9DLE9BQU87QUFDeEM7QUFFQUwsTUFBTU0sU0FBUyxDQUFDQyxZQUFZLEdBQUcsU0FBVUMsS0FBSztJQUM1QyxPQUFPLElBQUksQ0FBQ0wsSUFBSSxLQUFLSyxNQUFNTCxJQUFJLEdBQUcsSUFBSSxDQUFDTSxVQUFVLENBQUNELFNBQVUsS0FBSSxDQUFDTCxJQUFJLEdBQUdLLE1BQU1MLElBQUksSUFBSTtBQUN4RjtBQUVBSCxNQUFNTSxTQUFTLENBQUNHLFVBQVUsR0FBRyxTQUFVRCxLQUFLO0lBQzFDLE9BQU9FLEtBQUtDLElBQUksQ0FBQ0QsS0FBS0UsR0FBRyxDQUFDLElBQUksQ0FBQ1gsQ0FBQyxHQUFHTyxNQUFNUCxDQUFDLEVBQUUsS0FBS1MsS0FBS0UsR0FBRyxDQUFDLElBQUksQ0FBQ1YsQ0FBQyxHQUFHTSxNQUFNTixDQUFDLEVBQUU7QUFDOUU7QUFFQUYsTUFBTU0sU0FBUyxDQUFDTyxNQUFNLEdBQUcsU0FBVUMsS0FBSztJQUN0QyxPQUFPLElBQUksQ0FBQ2IsQ0FBQyxLQUFLYSxNQUFNYixDQUFDLElBQUksSUFBSSxDQUFDQyxDQUFDLEtBQUtZLE1BQU1aLENBQUMsSUFBSSxJQUFJLENBQUNDLElBQUksS0FBS1csTUFBTVgsSUFBSTtBQUM3RTtBQUVBLFNBQVNZLE9BQU9DLFVBQVUsRUFBRUMsUUFBUSxFQUFFQyxRQUFRLEVBQUVDLFFBQVE7SUFDdEQsSUFBSSxDQUFDSCxVQUFVLEdBQUdBO0lBQ2xCLElBQUksQ0FB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UUFFbEIsSUFBSyxJQUFJdE0sSUFBSSxHQUFHQSxJQUFJd00sTUFBTTVNLE1BQU0sRUFBRUksS0FBSyxFQUFHO1lBQ3hDdU0sTUFBTU4sV0FBVyxDQUFDTyxLQUFLLENBQUN4TSxFQUFFLENBQUMwTSxTQUFTLENBQUM7UUFDdkM7UUFFQUwsT0FBT0UsTUFBTUQsU0FBUztJQUN4QjtJQUVBLElBQUlLLFNBQVM7SUFDYixJQUFJQyxPQUFPUixTQUFTQyxPQUFPTTtJQUUzQixPQUFPUixTQUFTVSxLQUFLRDtBQUN2QjtBQUVBaEwsYUFBYTlDLFNBQVMsQ0FBQ2dPLFFBQVEsR0FBRyxTQUFVbkMsV0FBVztJQUNyRCxJQUFJb0MsU0FBUyxJQUFJO0lBRWpCLElBQUksQ0FBQ2pLLEtBQUs7SUFFVixJQUFJLENBQUM0SCxTQUFTLENBQUNDLGFBQWEsU0FBVS9ELEtBQUssRUFBRUMsTUFBTTtRQUNqRCxPQUFPa0csT0FBT2pHLFVBQVUsQ0FBQ0YsT0FBT0MsT0FBTzdILEtBQUssRUFBRTZILE9BQU9wRyxHQUFHO0lBQzFELEdBQUcsU0FBVXVLLFFBQVE7UUFDbkIsT0FBTytCLE9BQU83RixRQUFRLENBQUM4RDtJQUN6QjtJQUVBLElBQUksQ0FBQ3pHLEtBQUssR0FBR29HO0FBQ2Y7QUFFQS9JLGFBQWE5QyxTQUFTLENBQUNrTyxNQUFNLEdBQUc7SUFDOUIsT0FBTyxJQUFJLENBQUN6SSxLQUFLO0FBQ25CO0FBRUEsaUVBQWUzQyxZQUFZQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVudGFsLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NpZ25hdHVyZV9wYWQvZGlzdC9zaWduYXR1cmVfcGFkLm1qcz80ZWIwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogU2lnbmF0dXJlIFBhZCB2Mi4zLjJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zemltZWsvc2lnbmF0dXJlX3BhZFxuICpcbiAqIENvcHlyaWdodCAyMDE3IFN6eW1vbiBOb3dha1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKlxuICogVGhlIG1haW4gaWRlYSBhbmQgc29tZSBwYXJ0cyBvZiB0aGUgY29kZSAoZS5nLiBkcmF3aW5nIHZhcmlhYmxlIHdpZHRoIELDqXppZXIgY3VydmUpIGFyZSB0YWtlbiBmcm9tOlxuICogaHR0cDovL2Nvcm5lci5zcXVhcmV1cC5jb20vMjAxMi8wNy9zbW9vdGhlci1zaWduYXR1cmVzLmh0bWxcbiAqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiBpbnRlcnBvbGF0aW9uIHVzaW5nIGN1YmljIELDqXppZXIgY3VydmVzIGlzIHRha2VuIGZyb206XG4gKiBodHRwOi8vYmVua25vd3Njb2RlLndvcmRwcmVzcy5jb20vMjAxMi8wOS8xNC9wYXRoLWludGVycG9sYXRpb24tdXNpbmctY3ViaWMtYmV6aWVyLWFuZC1jb250cm9sLXBvaW50LWVzdGltYXRpb24taW4tamF2YXNjcmlwdFxuICpcbiAqIEFsZ29yaXRobSBmb3IgYXBwcm94aW1hdGVkIGxlbmd0aCBvZiBhIELDqXppZXIgY3VydmUgaXMgdGFrZW4gZnJvbTpcbiAqIGh0dHA6Ly93d3cubGVtb2RhLm5ldC9tYXRocy9iZXppZXItbGVuZ3RoL2luZGV4Lmh0bWxcbiAqXG4gKi9cblxuZnVuY3Rpb24gUG9pbnQoeCwgeSwgdGltZSkge1xuICB0aGlzLnggPSB4O1xuICB0aGlzLnkgPSB5O1xuICB0aGlzLnRpbWUgPSB0aW1lIHx8IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xufVxuXG5Qb2ludC5wcm90b3R5cGUudmVsb2NpdHlGcm9tID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG4gIHJldHVybiB0aGlzLnRpbWUgIT09IHN0YXJ0LnRpbWUgPyB0aGlzLmRpc3RhbmNlVG8oc3RhcnQpIC8gKHRoaXMudGltZSAtIHN0YXJ0LnRpbWUpIDogMTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5kaXN0YW5jZVRvID0gZnVuY3Rpb24gKHN0YXJ0KSB7XG4gIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3codGhpcy54IC0gc3RhcnQueCwgMikgKyBNYXRoLnBvdyh0aGlzLnkgLSBzdGFydC55LCAyKSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gIHJldHVybiB0aGlzLnggPT09IG90aGVyLnggJiYgdGhpcy55ID09PSBvdGhlci55ICYmIHRoaXMudGltZSA9PT0gb3RoZXIudGltZTtcbn07XG5cbmZ1bmN0aW9uIEJlemllcihzdGFydFBvaW50LCBjb250cm9sMSwgY29udHJvbDIsIGVuZFBvaW50KSB7XG4gIHRoaXMuc3RhcnRQb2ludCA9IHN0YXJ0UG9pbnQ7XG4gIHRoaXMuY29udHJvbDEgPSBjb250cm9sMTtcbiAgdGhpcy5jb250cm9sMiA9IGNvbnRyb2wyO1xuICB0aGlzLmVuZFBvaW50ID0gZW5kUG9pbnQ7XG59XG5cbi8vIFJldHVybnMgYXBwcm94aW1hdGVkIGxlbmd0aC5cbkJlemllci5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RlcHMgPSAxMDtcbiAgdmFyIGxlbmd0aCA9IDA7XG4gIHZhciBweCA9IHZvaWQgMDtcbiAgdmFyIHB5ID0gdm9pZCAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDw9IHN0ZXBzOyBpICs9IDEpIHtcbiAgICB2YXIgdCA9IGkgLyBzdGVwcztcbiAgICB2YXIgY3ggPSB0aGlzLl9wb2ludCh0LCB0aGlzLnN0YXJ0UG9pbnQueCwgdGhpcy5jb250cm9sMS54LCB0aGlzLmNvbnRyb2wyLngsIHRoaXMuZW5kUG9pbnQueCk7XG4gICAgdmFyIGN5ID0gdGhpcy5fcG9pbnQodCwgdGhpcy5zdGFydFBvaW50LnksIHRoaXMuY29udHJvbDEueSwgdGhpcy5jb250cm9sMi55LCB0aGlzLmVuZFBvaW50LnkpO1xuICAgIGlmIChpID4gMCkge1xuICAgICAgdmFyIHhkaWZmID0gY3ggLSBweDtcbiAgICAgIHZhciB5ZGlmZiA9IGN5IC0gcHk7XG4gICAgICBsZW5ndGggKz0gTWF0aC5zcXJ0KHhkaWZmICogeGRpZmYgKyB5ZGlmZiAqIHlkaWZmKTtcbiAgICB9XG4gICAgcHggPSBjeDtcbiAgICBweSA9IGN5O1xuICB9XG5cbiAgcmV0dXJuIGxlbmd0aDtcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLW11bHRpLXNwYWNlcywgc3BhY2UtaW4tcGFyZW5zICovXG5CZXppZXIucHJvdG90eXBlLl9wb2ludCA9IGZ1bmN0aW9uICh0LCBzdGFydCwgYzEsIGMyLCBlbmQpIHtcbiAgcmV0dXJuIHN0YXJ0ICogKDEuMCAtIHQpICogKDEuMCAtIHQpICogKDEuMCAtIHQpICsgMy4wICogYzEgKiAoMS4wIC0gdCkgKiAoMS4wIC0gdCkgKiB0ICsgMy4wICogYzIgKiAoMS4wIC0gdCkgKiB0ICogdCArIGVuZCAqIHQgKiB0ICogdDtcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlICovXG5cbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI3MDc4NDAxLzgxNTUwN1xuZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgY29udGV4dCwgYXJncywgcmVzdWx0O1xuICB2YXIgdGltZW91dCA9IG51bGw7XG4gIHZhciBwcmV2aW91cyA9IDA7XG4gIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICB2YXIgbGF0ZXIgPSBmdW5jdGlvbiBsYXRlcigpIHtcbiAgICBwcmV2aW91cyA9IG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UgPyAwIDogRGF0ZS5ub3coKTtcbiAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICB9O1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgIGlmICghcHJldmlvdXMgJiYgb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSkgcHJldmlvdXMgPSBub3c7XG4gICAgdmFyIHJlbWFpbmluZyA9IHdhaXQgLSAobm93IC0gcHJldmlvdXMpO1xuICAgIGNvbnRleHQgPSB0aGlzO1xuICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgaWYgKHJlbWFpbmluZyA8PSAwIHx8IHJlbWFpbmluZyA+IHdhaXQpIHtcbiAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICB9XG4gICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKCF0aW1lb3V0ICYmIG9wdGlvbnMudHJhaWxpbmcgIT09IGZhbHNlKSB7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgcmVtYWluaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gU2lnbmF0dXJlUGFkKGNhbnZhcywgb3B0aW9ucykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBvcHRzID0gb3B0aW9ucyB8fCB7fTtcblxuICB0aGlzLnZlbG9jaXR5RmlsdGVyV2VpZ2h0ID0gb3B0cy52ZWxvY2l0eUZpbHRlcldlaWdodCB8fCAwLjc7XG4gIHRoaXMubWluV2lkdGggPSBvcHRzLm1pbldpZHRoIHx8IDAuNTtcbiAgdGhpcy5tYXhXaWR0aCA9IG9wdHMubWF4V2lkdGggfHwgMi41O1xuICB0aGlzLnRocm90dGxlID0gJ3Rocm90dGxlJyBpbiBvcHRzID8gb3B0cy50aHJvdHRsZSA6IDE2OyAvLyBpbiBtaWxpc2Vjb25kc1xuICB0aGlzLm1pbkRpc3RhbmNlID0gJ21pbkRpc3RhbmNlJyBpbiBvcHRzID8gb3B0cy5taW5EaXN0YW5jZSA6IDU7XG5cbiAgaWYgKHRoaXMudGhyb3R0bGUpIHtcbiAgICB0aGlzLl9zdHJva2VNb3ZlVXBkYXRlID0gdGhyb3R0bGUoU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5fc3Ryb2tlVXBkYXRlLCB0aGlzLnRocm90dGxlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9zdHJva2VNb3ZlVXBkYXRlID0gU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5fc3Ryb2tlVXBkYXRlO1xuICB9XG5cbiAgdGhpcy5kb3RTaXplID0gb3B0cy5kb3RTaXplIHx8IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKHRoaXMubWluV2lkdGggKyB0aGlzLm1heFdpZHRoKSAvIDI7XG4gIH07XG4gIHRoaXMucGVuQ29sb3IgPSBvcHRzLnBlbkNvbG9yIHx8ICdibGFjayc7XG4gIHRoaXMuYmFja2dyb3VuZENvbG9yID0gb3B0cy5iYWNrZ3JvdW5kQ29sb3IgfHwgJ3JnYmEoMCwwLDAsMCknO1xuICB0aGlzLm9uQmVnaW4gPSBvcHRzLm9uQmVnaW47XG4gIHRoaXMub25FbmQgPSBvcHRzLm9uRW5kO1xuXG4gIHRoaXMuX2NhbnZhcyA9IGNhbnZhcztcbiAgdGhpcy5fY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIHRoaXMuY2xlYXIoKTtcblxuICAvLyBXZSBuZWVkIGFkZCB0aGVzZSBpbmxpbmUgc28gdGhleSBhcmUgYXZhaWxhYmxlIHRvIHVuYmluZCB3aGlsZSBzdGlsbCBoYXZpbmdcbiAgLy8gYWNjZXNzIHRvICdzZWxmJyB3ZSBjb3VsZCB1c2UgXy5iaW5kIGJ1dCBpdCdzIG5vdCB3b3J0aCBhZGRpbmcgYSBkZXBlbmRlbmN5LlxuICB0aGlzLl9oYW5kbGVNb3VzZURvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQud2hpY2ggPT09IDEpIHtcbiAgICAgIHNlbGYuX21vdXNlQnV0dG9uRG93biA9IHRydWU7XG4gICAgICBzZWxmLl9zdHJva2VCZWdpbihldmVudCk7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMuX2hhbmRsZU1vdXNlTW92ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChzZWxmLl9tb3VzZUJ1dHRvbkRvd24pIHtcbiAgICAgIHNlbGYuX3N0cm9rZU1vdmVVcGRhdGUoZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICB0aGlzLl9oYW5kbGVNb3VzZVVwID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LndoaWNoID09PSAxICYmIHNlbGYuX21vdXNlQnV0dG9uRG93bikge1xuICAgICAgc2VsZi5fbW91c2VCdXR0b25Eb3duID0gZmFsc2U7XG4gICAgICBzZWxmLl9zdHJva2VFbmQoZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICB0aGlzLl9oYW5kbGVUb3VjaFN0YXJ0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnRhcmdldFRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgdG91Y2ggPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICAgIHNlbGYuX3N0cm9rZUJlZ2luKHRvdWNoKTtcbiAgICB9XG4gIH07XG5cbiAgdGhpcy5faGFuZGxlVG91Y2hNb3ZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gUHJldmVudCBzY3JvbGxpbmcuXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgIHZhciB0b3VjaCA9IGV2ZW50LnRhcmdldFRvdWNoZXNbMF07XG4gICAgc2VsZi5fc3Ryb2tlTW92ZVVwZGF0ZSh0b3VjaCk7XG4gIH07XG5cbiAgdGhpcy5faGFuZGxlVG91Y2hFbmQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgd2FzQ2FudmFzVG91Y2hlZCA9IGV2ZW50LnRhcmdldCA9PT0gc2VsZi5fY2FudmFzO1xuICAgIGlmICh3YXNDYW52YXNUb3VjaGVkKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgc2VsZi5fc3Ryb2tlRW5kKGV2ZW50KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gRW5hYmxlIG1vdXNlIGFuZCB0b3VjaCBldmVudCBoYW5kbGVyc1xuICB0aGlzLm9uKCk7XG59XG5cbi8vIFB1YmxpYyBtZXRob2RzXG5TaWduYXR1cmVQYWQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICB2YXIgY2FudmFzID0gdGhpcy5fY2FudmFzO1xuXG4gIGN0eC5maWxsU3R5bGUgPSB0aGlzLmJhY2tncm91bmRDb2xvcjtcbiAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblxuICB0aGlzLl9kYXRhID0gW107XG4gIHRoaXMuX3Jlc2V0KCk7XG4gIHRoaXMuX2lzRW1wdHkgPSB0cnVlO1xufTtcblxuU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5mcm9tRGF0YVVSTCA9IGZ1bmN0aW9uIChkYXRhVXJsKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gIHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICB2YXIgcmF0aW8gPSBvcHRpb25zLnJhdGlvIHx8IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gIHZhciB3aWR0aCA9IG9wdGlvbnMud2lkdGggfHwgdGhpcy5fY2FudmFzLndpZHRoIC8gcmF0aW87XG4gIHZhciBoZWlnaHQgPSBvcHRpb25zLmhlaWdodCB8fCB0aGlzLl9jYW52YXMuaGVpZ2h0IC8gcmF0aW87XG5cbiAgdGhpcy5fcmVzZXQoKTtcbiAgaW1hZ2Uuc3JjID0gZGF0YVVybDtcbiAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgIF90aGlzLl9jdHguZHJhd0ltYWdlKGltYWdlLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgfTtcbiAgdGhpcy5faXNFbXB0eSA9IGZhbHNlO1xufTtcblxuU2lnbmF0dXJlUGFkLnByb3RvdHlwZS50b0RhdGFVUkwgPSBmdW5jdGlvbiAodHlwZSkge1xuICB2YXIgX2NhbnZhcztcblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdpbWFnZS9zdmcreG1sJzpcbiAgICAgIHJldHVybiB0aGlzLl90b1NWRygpO1xuICAgIGRlZmF1bHQ6XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgb3B0aW9ucyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgb3B0aW9uc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoX2NhbnZhcyA9IHRoaXMuX2NhbnZhcykudG9EYXRhVVJMLmFwcGx5KF9jYW52YXMsIFt0eXBlXS5jb25jYXQob3B0aW9ucykpO1xuICB9XG59O1xuXG5TaWduYXR1cmVQYWQucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9oYW5kbGVNb3VzZUV2ZW50cygpO1xuICB0aGlzLl9oYW5kbGVUb3VjaEV2ZW50cygpO1xufTtcblxuU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2NhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9oYW5kbGVNb3VzZURvd24pO1xuICB0aGlzLl9jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5faGFuZGxlTW91c2VNb3ZlKTtcbiAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX2hhbmRsZU1vdXNlVXApO1xuXG4gIHRoaXMuX2NhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5faGFuZGxlVG91Y2hTdGFydCk7XG4gIHRoaXMuX2NhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9oYW5kbGVUb3VjaE1vdmUpO1xuICB0aGlzLl9jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9oYW5kbGVUb3VjaEVuZCk7XG59O1xuXG5TaWduYXR1cmVQYWQucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9pc0VtcHR5O1xufTtcblxuLy8gUHJpdmF0ZSBtZXRob2RzXG5TaWduYXR1cmVQYWQucHJvdG90eXBlLl9zdHJva2VCZWdpbiA9IGZ1bmN0aW9uIChldmVudCkge1xuICB0aGlzLl9kYXRhLnB1c2goW10pO1xuICB0aGlzLl9yZXNldCgpO1xuICB0aGlzLl9zdHJva2VVcGRhdGUoZXZlbnQpO1xuXG4gIGlmICh0eXBlb2YgdGhpcy5vbkJlZ2luID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5vbkJlZ2luKGV2ZW50KTtcbiAgfVxufTtcblxuU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5fc3Ryb2tlVXBkYXRlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIHZhciB4ID0gZXZlbnQuY2xpZW50WDtcbiAgdmFyIHkgPSBldmVudC5jbGllbnRZO1xuXG4gIHZhciBwb2ludCA9IHRoaXMuX2NyZWF0ZVBvaW50KHgsIHkpO1xuICB2YXIgbGFzdFBvaW50R3JvdXAgPSB0aGlzLl9kYXRhW3RoaXMuX2RhdGEubGVuZ3RoIC0gMV07XG4gIHZhciBsYXN0UG9pbnQgPSBsYXN0UG9pbnRHcm91cCAmJiBsYXN0UG9pbnRHcm91cFtsYXN0UG9pbnRHcm91cC5sZW5ndGggLSAxXTtcbiAgdmFyIGlzTGFzdFBvaW50VG9vQ2xvc2UgPSBsYXN0UG9pbnQgJiYgcG9pbnQuZGlzdGFuY2VUbyhsYXN0UG9pbnQpIDwgdGhpcy5taW5EaXN0YW5jZTtcblxuICAvLyBTa2lwIHRoaXMgcG9pbnQgaWYgaXQncyB0b28gY2xvc2UgdG8gdGhlIHByZXZpb3VzIG9uZVxuICBpZiAoIShsYXN0UG9pbnQgJiYgaXNMYXN0UG9pbnRUb29DbG9zZSkpIHtcbiAgICB2YXIgX2FkZFBvaW50ID0gdGhpcy5fYWRkUG9pbnQocG9pbnQpLFxuICAgICAgICBjdXJ2ZSA9IF9hZGRQb2ludC5jdXJ2ZSxcbiAgICAgICAgd2lkdGhzID0gX2FkZFBvaW50LndpZHRocztcblxuICAgIGlmIChjdXJ2ZSAmJiB3aWR0aHMpIHtcbiAgICAgIHRoaXMuX2RyYXdDdXJ2ZShjdXJ2ZSwgd2lkdGhzLnN0YXJ0LCB3aWR0aHMuZW5kKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kYXRhW3RoaXMuX2RhdGEubGVuZ3RoIC0gMV0ucHVzaCh7XG4gICAgICB4OiBwb2ludC54LFxuICAgICAgeTogcG9pbnQueSxcbiAgICAgIHRpbWU6IHBvaW50LnRpbWUsXG4gICAgICBjb2xvcjogdGhpcy5wZW5Db2xvclxuICAgIH0pO1xuICB9XG59O1xuXG5TaWduYXR1cmVQYWQucHJvdG90eXBlLl9zdHJva2VFbmQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgdmFyIGNhbkRyYXdDdXJ2ZSA9IHRoaXMucG9pbnRzLmxlbmd0aCA+IDI7XG4gIHZhciBwb2ludCA9IHRoaXMucG9pbnRzWzBdOyAvLyBQb2ludCBpbnN0YW5jZVxuXG4gIGlmICghY2FuRHJhd0N1cnZlICYmIHBvaW50KSB7XG4gICAgdGhpcy5fZHJhd0RvdChwb2ludCk7XG4gIH1cblxuICBpZiAocG9pbnQpIHtcbiAgICB2YXIgbGFzdFBvaW50R3JvdXAgPSB0aGlzLl9kYXRhW3RoaXMuX2RhdGEubGVuZ3RoIC0gMV07XG4gICAgdmFyIGxhc3RQb2ludCA9IGxhc3RQb2ludEdyb3VwW2xhc3RQb2ludEdyb3VwLmxlbmd0aCAtIDFdOyAvLyBwbGFpbiBvYmplY3RcblxuICAgIC8vIFdoZW4gZHJhd2luZyBhIGRvdCwgdGhlcmUncyBvbmx5IG9uZSBwb2ludCBpbiBhIGdyb3VwLCBzbyB3aXRob3V0IHRoaXMgY2hlY2tcbiAgICAvLyBzdWNoIGdyb3VwIHdvdWxkIGVuZCB1cCB3aXRoIGV4YWN0bHkgdGhlIHNhbWUgMiBwb2ludHMuXG4gICAgaWYgKCFwb2ludC5lcXVhbHMobGFzdFBvaW50KSkge1xuICAgICAgbGFzdFBvaW50R3JvdXAucHVzaCh7XG4gICAgICAgIHg6IHBvaW50LngsXG4gICAgICAgIHk6IHBvaW50LnksXG4gICAgICAgIHRpbWU6IHBvaW50LnRpbWUsXG4gICAgICAgIGNvbG9yOiB0aGlzLnBlbkNvbG9yXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHRoaXMub25FbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLm9uRW5kKGV2ZW50KTtcbiAgfVxufTtcblxuU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5faGFuZGxlTW91c2VFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX21vdXNlQnV0dG9uRG93biA9IGZhbHNlO1xuXG4gIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9oYW5kbGVNb3VzZURvd24pO1xuICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5faGFuZGxlTW91c2VNb3ZlKTtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX2hhbmRsZU1vdXNlVXApO1xufTtcblxuU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5faGFuZGxlVG91Y2hFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFBhc3MgdG91Y2ggZXZlbnRzIHRvIGNhbnZhcyBlbGVtZW50IG9uIG1vYmlsZSBJRTExIGFuZCBFZGdlLlxuICB0aGlzLl9jYW52YXMuc3R5bGUubXNUb3VjaEFjdGlvbiA9ICdub25lJztcbiAgdGhpcy5fY2FudmFzLnN0eWxlLnRvdWNoQWN0aW9uID0gJ25vbmUnO1xuXG4gIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5faGFuZGxlVG91Y2hTdGFydCk7XG4gIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9oYW5kbGVUb3VjaE1vdmUpO1xuICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9oYW5kbGVUb3VjaEVuZCk7XG59O1xuXG5TaWduYXR1cmVQYWQucHJvdG90eXBlLl9yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5wb2ludHMgPSBbXTtcbiAgdGhpcy5fbGFzdFZlbG9jaXR5ID0gMDtcbiAgdGhpcy5fbGFzdFdpZHRoID0gKHRoaXMubWluV2lkdGggKyB0aGlzLm1heFdpZHRoKSAvIDI7XG4gIHRoaXMuX2N0eC5maWxsU3R5bGUgPSB0aGlzLnBlbkNvbG9yO1xufTtcblxuU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5fY3JlYXRlUG9pbnQgPSBmdW5jdGlvbiAoeCwgeSwgdGltZSkge1xuICB2YXIgcmVjdCA9IHRoaXMuX2NhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICByZXR1cm4gbmV3IFBvaW50KHggLSByZWN0LmxlZnQsIHkgLSByZWN0LnRvcCwgdGltZSB8fCBuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XG59O1xuXG5TaWduYXR1cmVQYWQucHJvdG90eXBlLl9hZGRQb2ludCA9IGZ1bmN0aW9uIChwb2ludCkge1xuICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gIHZhciB0bXAgPSB2b2lkIDA7XG5cbiAgcG9pbnRzLnB1c2gocG9pbnQpO1xuXG4gIGlmIChwb2ludHMubGVuZ3RoID4gMikge1xuICAgIC8vIFRvIHJlZHVjZSB0aGUgaW5pdGlhbCBsYWcgbWFrZSBpdCB3b3JrIHdpdGggMyBwb2ludHNcbiAgICAvLyBieSBjb3B5aW5nIHRoZSBmaXJzdCBwb2ludCB0byB0aGUgYmVnaW5uaW5nLlxuICAgIGlmIChwb2ludHMubGVuZ3RoID09PSAzKSBwb2ludHMudW5zaGlmdChwb2ludHNbMF0pO1xuXG4gICAgdG1wID0gdGhpcy5fY2FsY3VsYXRlQ3VydmVDb250cm9sUG9pbnRzKHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0pO1xuICAgIHZhciBjMiA9IHRtcC5jMjtcbiAgICB0bXAgPSB0aGlzLl9jYWxjdWxhdGVDdXJ2ZUNvbnRyb2xQb2ludHMocG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSk7XG4gICAgdmFyIGMzID0gdG1wLmMxO1xuICAgIHZhciBjdXJ2ZSA9IG5ldyBCZXppZXIocG9pbnRzWzFdLCBjMiwgYzMsIHBvaW50c1syXSk7XG4gICAgdmFyIHdpZHRocyA9IHRoaXMuX2NhbGN1bGF0ZUN1cnZlV2lkdGhzKGN1cnZlKTtcblxuICAgIC8vIFJlbW92ZSB0aGUgZmlyc3QgZWxlbWVudCBmcm9tIHRoZSBsaXN0LFxuICAgIC8vIHNvIHRoYXQgd2UgYWx3YXlzIGhhdmUgbm8gbW9yZSB0aGFuIDQgcG9pbnRzIGluIHBvaW50cyBhcnJheS5cbiAgICBwb2ludHMuc2hpZnQoKTtcblxuICAgIHJldHVybiB7IGN1cnZlOiBjdXJ2ZSwgd2lkdGhzOiB3aWR0aHMgfTtcbiAgfVxuXG4gIHJldHVybiB7fTtcbn07XG5cblNpZ25hdHVyZVBhZC5wcm90b3R5cGUuX2NhbGN1bGF0ZUN1cnZlQ29udHJvbFBvaW50cyA9IGZ1bmN0aW9uIChzMSwgczIsIHMzKSB7XG4gIHZhciBkeDEgPSBzMS54IC0gczIueDtcbiAgdmFyIGR5MSA9IHMxLnkgLSBzMi55O1xuICB2YXIgZHgyID0gczIueCAtIHMzLng7XG4gIHZhciBkeTIgPSBzMi55IC0gczMueTtcblxuICB2YXIgbTEgPSB7IHg6IChzMS54ICsgczIueCkgLyAyLjAsIHk6IChzMS55ICsgczIueSkgLyAyLjAgfTtcbiAgdmFyIG0yID0geyB4OiAoczIueCArIHMzLngpIC8gMi4wLCB5OiAoczIueSArIHMzLnkpIC8gMi4wIH07XG5cbiAgdmFyIGwxID0gTWF0aC5zcXJ0KGR4MSAqIGR4MSArIGR5MSAqIGR5MSk7XG4gIHZhciBsMiA9IE1hdGguc3FydChkeDIgKiBkeDIgKyBkeTIgKiBkeTIpO1xuXG4gIHZhciBkeG0gPSBtMS54IC0gbTIueDtcbiAgdmFyIGR5bSA9IG0xLnkgLSBtMi55O1xuXG4gIHZhciBrID0gbDIgLyAobDEgKyBsMik7XG4gIHZhciBjbSA9IHsgeDogbTIueCArIGR4bSAqIGssIHk6IG0yLnkgKyBkeW0gKiBrIH07XG5cbiAgdmFyIHR4ID0gczIueCAtIGNtLng7XG4gIHZhciB0eSA9IHMyLnkgLSBjbS55O1xuXG4gIHJldHVybiB7XG4gICAgYzE6IG5ldyBQb2ludChtMS54ICsgdHgsIG0xLnkgKyB0eSksXG4gICAgYzI6IG5ldyBQb2ludChtMi54ICsgdHgsIG0yLnkgKyB0eSlcbiAgfTtcbn07XG5cblNpZ25hdHVyZVBhZC5wcm90b3R5cGUuX2NhbGN1bGF0ZUN1cnZlV2lkdGhzID0gZnVuY3Rpb24gKGN1cnZlKSB7XG4gIHZhciBzdGFydFBvaW50ID0gY3VydmUuc3RhcnRQb2ludDtcbiAgdmFyIGVuZFBvaW50ID0gY3VydmUuZW5kUG9pbnQ7XG4gIHZhciB3aWR0aHMgPSB7IHN0YXJ0OiBudWxsLCBlbmQ6IG51bGwgfTtcblxuICB2YXIgdmVsb2NpdHkgPSB0aGlzLnZlbG9jaXR5RmlsdGVyV2VpZ2h0ICogZW5kUG9pbnQudmVsb2NpdHlGcm9tKHN0YXJ0UG9pbnQpICsgKDEgLSB0aGlzLnZlbG9jaXR5RmlsdGVyV2VpZ2h0KSAqIHRoaXMuX2xhc3RWZWxvY2l0eTtcblxuICB2YXIgbmV3V2lkdGggPSB0aGlzLl9zdHJva2VXaWR0aCh2ZWxvY2l0eSk7XG5cbiAgd2lkdGhzLnN0YXJ0ID0gdGhpcy5fbGFzdFdpZHRoO1xuICB3aWR0aHMuZW5kID0gbmV3V2lkdGg7XG5cbiAgdGhpcy5fbGFzdFZlbG9jaXR5ID0gdmVsb2NpdHk7XG4gIHRoaXMuX2xhc3RXaWR0aCA9IG5ld1dpZHRoO1xuXG4gIHJldHVybiB3aWR0aHM7XG59O1xuXG5TaWduYXR1cmVQYWQucHJvdG90eXBlLl9zdHJva2VXaWR0aCA9IGZ1bmN0aW9uICh2ZWxvY2l0eSkge1xuICByZXR1cm4gTWF0aC5tYXgodGhpcy5tYXhXaWR0aCAvICh2ZWxvY2l0eSArIDEpLCB0aGlzLm1pbldpZHRoKTtcbn07XG5cblNpZ25hdHVyZVBhZC5wcm90b3R5cGUuX2RyYXdQb2ludCA9IGZ1bmN0aW9uICh4LCB5LCBzaXplKSB7XG4gIHZhciBjdHggPSB0aGlzLl9jdHg7XG5cbiAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgY3R4LmFyYyh4LCB5LCBzaXplLCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xuICB0aGlzLl9pc0VtcHR5ID0gZmFsc2U7XG59O1xuXG5TaWduYXR1cmVQYWQucHJvdG90eXBlLl9kcmF3Q3VydmUgPSBmdW5jdGlvbiAoY3VydmUsIHN0YXJ0V2lkdGgsIGVuZFdpZHRoKSB7XG4gIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gIHZhciB3aWR0aERlbHRhID0gZW5kV2lkdGggLSBzdGFydFdpZHRoO1xuICB2YXIgZHJhd1N0ZXBzID0gTWF0aC5mbG9vcihjdXJ2ZS5sZW5ndGgoKSk7XG5cbiAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZHJhd1N0ZXBzOyBpICs9IDEpIHtcbiAgICAvLyBDYWxjdWxhdGUgdGhlIEJlemllciAoeCwgeSkgY29vcmRpbmF0ZSBmb3IgdGhpcyBzdGVwLlxuICAgIHZhciB0ID0gaSAvIGRyYXdTdGVwcztcbiAgICB2YXIgdHQgPSB0ICogdDtcbiAgICB2YXIgdHR0ID0gdHQgKiB0O1xuICAgIHZhciB1ID0gMSAtIHQ7XG4gICAgdmFyIHV1ID0gdSAqIHU7XG4gICAgdmFyIHV1dSA9IHV1ICogdTtcblxuICAgIHZhciB4ID0gdXV1ICogY3VydmUuc3RhcnRQb2ludC54O1xuICAgIHggKz0gMyAqIHV1ICogdCAqIGN1cnZlLmNvbnRyb2wxLng7XG4gICAgeCArPSAzICogdSAqIHR0ICogY3VydmUuY29udHJvbDIueDtcbiAgICB4ICs9IHR0dCAqIGN1cnZlLmVuZFBvaW50Lng7XG5cbiAgICB2YXIgeSA9IHV1dSAqIGN1cnZlLnN0YXJ0UG9pbnQueTtcbiAgICB5ICs9IDMgKiB1dSAqIHQgKiBjdXJ2ZS5jb250cm9sMS55O1xuICAgIHkgKz0gMyAqIHUgKiB0dCAqIGN1cnZlLmNvbnRyb2wyLnk7XG4gICAgeSArPSB0dHQgKiBjdXJ2ZS5lbmRQb2ludC55O1xuXG4gICAgdmFyIHdpZHRoID0gc3RhcnRXaWR0aCArIHR0dCAqIHdpZHRoRGVsdGE7XG4gICAgdGhpcy5fZHJhd1BvaW50KHgsIHksIHdpZHRoKTtcbiAgfVxuXG4gIGN0eC5jbG9zZVBhdGgoKTtcbiAgY3R4LmZpbGwoKTtcbn07XG5cblNpZ25hdHVyZVBhZC5wcm90b3R5cGUuX2RyYXdEb3QgPSBmdW5jdGlvbiAocG9pbnQpIHtcbiAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgdmFyIHdpZHRoID0gdHlwZW9mIHRoaXMuZG90U2l6ZSA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMuZG90U2l6ZSgpIDogdGhpcy5kb3RTaXplO1xuXG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgdGhpcy5fZHJhd1BvaW50KHBvaW50LngsIHBvaW50LnksIHdpZHRoKTtcbiAgY3R4LmNsb3NlUGF0aCgpO1xuICBjdHguZmlsbCgpO1xufTtcblxuU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5fZnJvbURhdGEgPSBmdW5jdGlvbiAocG9pbnRHcm91cHMsIGRyYXdDdXJ2ZSwgZHJhd0RvdCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50R3JvdXBzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgdmFyIGdyb3VwID0gcG9pbnRHcm91cHNbaV07XG5cbiAgICBpZiAoZ3JvdXAubGVuZ3RoID4gMSkge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBncm91cC5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICB2YXIgcmF3UG9pbnQgPSBncm91cFtqXTtcbiAgICAgICAgdmFyIHBvaW50ID0gbmV3IFBvaW50KHJhd1BvaW50LngsIHJhd1BvaW50LnksIHJhd1BvaW50LnRpbWUpO1xuICAgICAgICB2YXIgY29sb3IgPSByYXdQb2ludC5jb2xvcjtcblxuICAgICAgICBpZiAoaiA9PT0gMCkge1xuICAgICAgICAgIC8vIEZpcnN0IHBvaW50IGluIGEgZ3JvdXAuIE5vdGhpbmcgdG8gZHJhdyB5ZXQuXG5cbiAgICAgICAgICAvLyBBbGwgcG9pbnRzIGluIHRoZSBncm91cCBoYXZlIHRoZSBzYW1lIGNvbG9yLCBzbyBpdCdzIGVub3VnaCB0byBzZXRcbiAgICAgICAgICAvLyBwZW5Db2xvciBqdXN0IGF0IHRoZSBiZWdpbm5pbmcuXG4gICAgICAgICAgdGhpcy5wZW5Db2xvciA9IGNvbG9yO1xuICAgICAgICAgIHRoaXMuX3Jlc2V0KCk7XG5cbiAgICAgICAgICB0aGlzLl9hZGRQb2ludChwb2ludCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaiAhPT0gZ3JvdXAubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIC8vIE1pZGRsZSBwb2ludCBpbiBhIGdyb3VwLlxuICAgICAgICAgIHZhciBfYWRkUG9pbnQyID0gdGhpcy5fYWRkUG9pbnQocG9pbnQpLFxuICAgICAgICAgICAgICBjdXJ2ZSA9IF9hZGRQb2ludDIuY3VydmUsXG4gICAgICAgICAgICAgIHdpZHRocyA9IF9hZGRQb2ludDIud2lkdGhzO1xuXG4gICAgICAgICAgaWYgKGN1cnZlICYmIHdpZHRocykge1xuICAgICAgICAgICAgZHJhd0N1cnZlKGN1cnZlLCB3aWR0aHMsIGNvbG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTGFzdCBwb2ludCBpbiBhIGdyb3VwLiBEbyBub3RoaW5nLlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgICB2YXIgX3Jhd1BvaW50ID0gZ3JvdXBbMF07XG4gICAgICBkcmF3RG90KF9yYXdQb2ludCk7XG4gICAgfVxuICB9XG59O1xuXG5TaWduYXR1cmVQYWQucHJvdG90eXBlLl90b1NWRyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgdmFyIHBvaW50R3JvdXBzID0gdGhpcy5fZGF0YTtcbiAgdmFyIGNhbnZhcyA9IHRoaXMuX2NhbnZhcztcbiAgdmFyIHJhdGlvID0gTWF0aC5tYXgod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSwgMSk7XG4gIHZhciBtaW5YID0gMDtcbiAgdmFyIG1pblkgPSAwO1xuICB2YXIgbWF4WCA9IGNhbnZhcy53aWR0aCAvIHJhdGlvO1xuICB2YXIgbWF4WSA9IGNhbnZhcy5oZWlnaHQgLyByYXRpbztcbiAgdmFyIHN2ZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAnc3ZnJyk7XG5cbiAgc3ZnLnNldEF0dHJpYnV0ZU5TKG51bGwsICd3aWR0aCcsIGNhbnZhcy53aWR0aCk7XG4gIHN2Zy5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnaGVpZ2h0JywgY2FudmFzLmhlaWdodCk7XG5cbiAgdGhpcy5fZnJvbURhdGEocG9pbnRHcm91cHMsIGZ1bmN0aW9uIChjdXJ2ZSwgd2lkdGhzLCBjb2xvcikge1xuICAgIHZhciBwYXRoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncGF0aCcpO1xuXG4gICAgLy8gTmVlZCB0byBjaGVjayBjdXJ2ZSBmb3IgTmFOIHZhbHVlcywgdGhlc2UgcG9wIHVwIHdoZW4gZHJhd2luZ1xuICAgIC8vIGxpbmVzIG9uIHRoZSBjYW52YXMgdGhhdCBhcmUgbm90IGNvbnRpbnVvdXMuIEUuZy4gU2hhcnAgY29ybmVyc1xuICAgIC8vIG9yIHN0b3BwaW5nIG1pZC1zdHJva2UgYW5kIHRoYW4gY29udGludWluZyB3aXRob3V0IGxpZnRpbmcgbW91c2UuXG4gICAgaWYgKCFpc05hTihjdXJ2ZS5jb250cm9sMS54KSAmJiAhaXNOYU4oY3VydmUuY29udHJvbDEueSkgJiYgIWlzTmFOKGN1cnZlLmNvbnRyb2wyLngpICYmICFpc05hTihjdXJ2ZS5jb250cm9sMi55KSkge1xuICAgICAgdmFyIGF0dHIgPSAnTSAnICsgY3VydmUuc3RhcnRQb2ludC54LnRvRml4ZWQoMykgKyAnLCcgKyBjdXJ2ZS5zdGFydFBvaW50LnkudG9GaXhlZCgzKSArICcgJyArICgnQyAnICsgY3VydmUuY29udHJvbDEueC50b0ZpeGVkKDMpICsgJywnICsgY3VydmUuY29udHJvbDEueS50b0ZpeGVkKDMpICsgJyAnKSArIChjdXJ2ZS5jb250cm9sMi54LnRvRml4ZWQoMykgKyAnLCcgKyBjdXJ2ZS5jb250cm9sMi55LnRvRml4ZWQoMykgKyAnICcpICsgKGN1cnZlLmVuZFBvaW50LngudG9GaXhlZCgzKSArICcsJyArIGN1cnZlLmVuZFBvaW50LnkudG9GaXhlZCgzKSk7XG5cbiAgICAgIHBhdGguc2V0QXR0cmlidXRlKCdkJywgYXR0cik7XG4gICAgICBwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywgKHdpZHRocy5lbmQgKiAyLjI1KS50b0ZpeGVkKDMpKTtcbiAgICAgIHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UnLCBjb2xvcik7XG4gICAgICBwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbCcsICdub25lJyk7XG4gICAgICBwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVjYXAnLCAncm91bmQnKTtcblxuICAgICAgc3ZnLmFwcGVuZENoaWxkKHBhdGgpO1xuICAgIH1cbiAgfSwgZnVuY3Rpb24gKHJhd1BvaW50KSB7XG4gICAgdmFyIGNpcmNsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NpcmNsZScpO1xuICAgIHZhciBkb3RTaXplID0gdHlwZW9mIF90aGlzMi5kb3RTaXplID09PSAnZnVuY3Rpb24nID8gX3RoaXMyLmRvdFNpemUoKSA6IF90aGlzMi5kb3RTaXplO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoJ3InLCBkb3RTaXplKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKCdjeCcsIHJhd1BvaW50LngpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoJ2N5JywgcmF3UG9pbnQueSk7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZSgnZmlsbCcsIHJhd1BvaW50LmNvbG9yKTtcblxuICAgIHN2Zy5hcHBlbmRDaGlsZChjaXJjbGUpO1xuICB9KTtcblxuICB2YXIgcHJlZml4ID0gJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsJztcbiAgdmFyIGhlYWRlciA9ICc8c3ZnJyArICcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiJyArICcgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCInICsgKCcgdmlld0JveD1cIicgKyBtaW5YICsgJyAnICsgbWluWSArICcgJyArIG1heFggKyAnICcgKyBtYXhZICsgJ1wiJykgKyAoJyB3aWR0aD1cIicgKyBtYXhYICsgJ1wiJykgKyAoJyBoZWlnaHQ9XCInICsgbWF4WSArICdcIicpICsgJz4nO1xuICB2YXIgYm9keSA9IHN2Zy5pbm5lckhUTUw7XG5cbiAgLy8gSUUgaGFjayBmb3IgbWlzc2luZyBpbm5lckhUTUwgcHJvcGVydHkgb24gU1ZHRWxlbWVudFxuICBpZiAoYm9keSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGR1bW15ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZHVtbXknKTtcbiAgICB2YXIgbm9kZXMgPSBzdmcuY2hpbGROb2RlcztcbiAgICBkdW1teS5pbm5lckhUTUwgPSAnJztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGR1bW15LmFwcGVuZENoaWxkKG5vZGVzW2ldLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgfVxuXG4gICAgYm9keSA9IGR1bW15LmlubmVySFRNTDtcbiAgfVxuXG4gIHZhciBmb290ZXIgPSAnPC9zdmc+JztcbiAgdmFyIGRhdGEgPSBoZWFkZXIgKyBib2R5ICsgZm9vdGVyO1xuXG4gIHJldHVybiBwcmVmaXggKyBidG9hKGRhdGEpO1xufTtcblxuU2lnbmF0dXJlUGFkLnByb3RvdHlwZS5mcm9tRGF0YSA9IGZ1bmN0aW9uIChwb2ludEdyb3Vwcykge1xuICB2YXIgX3RoaXMzID0gdGhpcztcblxuICB0aGlzLmNsZWFyKCk7XG5cbiAgdGhpcy5fZnJvbURhdGEocG9pbnRHcm91cHMsIGZ1bmN0aW9uIChjdXJ2ZSwgd2lkdGhzKSB7XG4gICAgcmV0dXJuIF90aGlzMy5fZHJhd0N1cnZlKGN1cnZlLCB3aWR0aHMuc3RhcnQsIHdpZHRocy5lbmQpO1xuICB9LCBmdW5jdGlvbiAocmF3UG9pbnQpIHtcbiAgICByZXR1cm4gX3RoaXMzLl9kcmF3RG90KHJhd1BvaW50KTtcbiAgfSk7XG5cbiAgdGhpcy5fZGF0YSA9IHBvaW50R3JvdXBzO1xufTtcblxuU2lnbmF0dXJlUGFkLnByb3RvdHlwZS50b0RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9kYXRhO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgU2lnbmF0dXJlUGFkO1xuIl0sIm5hbWVzIjpbIlBvaW50IiwieCIsInkiLCJ0aW1lIiwiRGF0ZSIsImdldFRpbWUiLCJwcm90b3R5cGUiLCJ2ZWxvY2l0eUZyb20iLCJzdGFydCIsImRpc3RhbmNlVG8iLCJNYXRoIiwic3FydCIsInBvdyIsImVxdWFscyIsIm90aGVyIiwiQmV6aWVyIiwic3RhcnRQb2ludCIsImNvbnRyb2wxIiwiY29udHJvbDIiLCJlbmRQb2ludCIsImxlbmd0aCIsInN0ZXBzIiwicHgiLCJweSIsImkiLCJ0IiwiY3giLCJfcG9pbnQiLCJjeSIsInhkaWZmIiwieWRpZmYiLCJjMSIsImMyIiwiZW5kIiwidGhyb3R0bGUiLCJmdW5jIiwid2FpdCIsIm9wdGlvbnMiLCJjb250ZXh0IiwiYXJncyIsInJlc3VsdCIsInRpbWVvdXQiLCJwcmV2aW91cyIsImxhdGVyIiwibGVhZGluZyIsIm5vdyIsImFwcGx5IiwicmVtYWluaW5nIiwiYXJndW1lbnRzIiwiY2xlYXJUaW1lb3V0IiwidHJhaWxpbmciLCJzZXRUaW1lb3V0IiwiU2lnbmF0dXJlUGFkIiwiY2FudmFzIiwic2VsZiIsIm9wdHMiLCJ2ZWxvY2l0eUZpbHRlcldlaWdodCIsIm1pbldpZHRoIiwibWF4V2lkdGgiLCJtaW5EaXN0YW5jZSIsIl9zdHJva2VNb3ZlVXBkYXRlIiwiX3N0cm9rZVVwZGF0ZSIsImRvdFNpemUiLCJwZW5Db2xvciIsImJhY2tncm91bmRDb2xvciIsIm9uQmVnaW4iLCJvbkVuZCIsIl9jYW52YXMiLCJfY3R4IiwiZ2V0Q29udGV4dCIsImNsZWFyIiwiX2hhbmRsZU1vdXNlRG93biIsImV2ZW50Iiwid2hpY2giLCJfbW91c2VCdXR0b25Eb3duIiwiX3N0cm9rZUJlZ2luIiwiX2hhbmRsZU1vdXNlTW92ZSIsIl9oYW5kbGVNb3VzZVVwIiwiX3N0cm9rZUVuZCIsIl9oYW5kbGVUb3VjaFN0YXJ0IiwidGFyZ2V0VG91Y2hlcyIsInRvdWNoIiwiY2hhbmdlZFRvdWNoZXMiLCJfaGFuZGxlVG91Y2hNb3ZlIiwicHJldmVudERlZmF1bHQiLCJfaGFuZGxlVG91Y2hFbmQiLCJ3YXNDYW52YXNUb3VjaGVkIiwidGFyZ2V0Iiwib24iLCJjdHgiLCJmaWxsU3R5bGUiLCJjbGVhclJlY3QiLCJ3aWR0aCIsImhlaWdodCIsImZpbGxSZWN0IiwiX2RhdGEiLCJfcmVzZXQiLCJfaXNFbXB0eSIsImZyb21EYXRhVVJMIiwiZGF0YVVybCIsIl90aGlzIiwidW5kZWZpbmVkIiwiaW1hZ2UiLCJJbWFnZSIsInJhdGlvIiwid2luZG93IiwiZGV2aWNlUGl4ZWxSYXRpbyIsInNyYyIsIm9ubG9hZCIsImRyYXdJbWFnZSIsInRvRGF0YVVSTCIsInR5cGUiLCJfdG9TVkciLCJfbGVuIiwiQXJyYXkiLCJfa2V5IiwiY29uY2F0IiwiX2hhbmRsZU1vdXNlRXZlbnRzIiwiX2hhbmRsZVRvdWNoRXZlbnRzIiwib2ZmIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImRvY3VtZW50IiwiaXNFbXB0eSIsInB1c2giLCJjbGllbnRYIiwiY2xpZW50WSIsInBvaW50IiwiX2NyZWF0ZVBvaW50IiwibGFzdFBvaW50R3JvdXAiLCJsYXN0UG9pbnQiLCJpc0xhc3RQb2ludFRvb0Nsb3NlIiwiX2FkZFBvaW50IiwiY3VydmUiLCJ3aWR0aHMiLCJfZHJhd0N1cnZlIiwiY29sb3IiLCJjYW5EcmF3Q3VydmUiLCJwb2ludHMiLCJfZHJhd0RvdCIsImFkZEV2ZW50TGlzdGVuZXIiLCJzdHlsZSIsIm1zVG91Y2hBY3Rpb24iLCJ0b3VjaEFjdGlvbiIsIl9sYXN0VmVsb2NpdHkiLCJfbGFzdFdpZHRoIiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImxlZnQiLCJ0b3AiLCJ0bXAiLCJ1bnNoaWZ0IiwiX2NhbGN1bGF0ZUN1cnZlQ29udHJvbFBvaW50cyIsImMzIiwiX2NhbGN1bGF0ZUN1cnZlV2lkdGhzIiwic2hpZnQiLCJzMSIsInMyIiwiczMiLCJkeDEiLCJkeTEiLCJkeDIiLCJkeTIiLCJtMSIsIm0yIiwibDEiLCJsMiIsImR4bSIsImR5bSIsImsiLCJjbSIsInR4IiwidHkiLCJ2ZWxvY2l0eSIsIm5ld1dpZHRoIiwiX3N0cm9rZVdpZHRoIiwibWF4IiwiX2RyYXdQb2ludCIsInNpemUiLCJtb3ZlVG8iLCJhcmMiLCJQSSIsInN0YXJ0V2lkdGgiLCJlbmRXaWR0aCIsIndpZHRoRGVsdGEiLCJkcmF3U3RlcHMiLCJmbG9vciIsImJlZ2luUGF0aCIsInR0IiwidHR0IiwidSIsInV1IiwidXV1IiwiY2xvc2VQYXRoIiwiZmlsbCIsIl9mcm9tRGF0YSIsInBvaW50R3JvdXBzIiwiZHJhd0N1cnZlIiwiZHJhd0RvdCIsImdyb3VwIiwiaiIsInJhd1BvaW50IiwiX2FkZFBvaW50MiIsIl9yYXdQb2ludCIsIl90aGlzMiIsIm1pblgiLCJtaW5ZIiwibWF4WCIsIm1heFkiLCJzdmciLCJjcmVhdGVFbGVtZW50TlMiLCJzZXRBdHRyaWJ1dGVOUyIsInBhdGgiLCJjcmVhdGVFbGVtZW50IiwiaXNOYU4iLCJhdHRyIiwidG9GaXhlZCIsInNldEF0dHJpYnV0ZSIsImFwcGVuZENoaWxkIiwiY2lyY2xlIiwicHJlZml4IiwiaGVhZGVyIiwiYm9keSIsImlubmVySFRNTCIsImR1bW15Iiwibm9kZXMiLCJjaGlsZE5vZGVzIiwiY2xvbmVOb2RlIiwiZm9vdGVyIiwiZGF0YSIsImJ0b2EiLCJmcm9tRGF0YSIsIl90aGlzMyIsInRvRGF0YSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/signature_pad/dist/signature_pad.mjs\n");

/***/ })

};
;